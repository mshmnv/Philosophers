* deadlock
* queue for threads
* queue: 1->3->5 eats


#include <pthread.h>


int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
	(attr - NULL | start_routine - функция над arg)



int pthread_join(pthread_t thread, void **retval);
	(retval = NULL)
	- waits for the thread


int pthread_detach(pthread_t thread);
	- When a detached thread terminates, its resources are automatically released back to the system
	- внутри потока (в start_routine ф-и)


** MUTEX **

int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
	(restrict attr = NULL)
int pthread_mutex_lock (pthread_mutex_t *mutex);
	- один поток заблокировал мьютекс -> другой не может это сделать (ждет пока будет разблокирован)
int pthread_mutex_unlock (pthread_mutex_t *mutex);




** SEMAPHOR ** (philo_three, где философы это разные процессы)

sem_init(sem_t *sem, int pshared, unsigned int value);
	- value > 0 (сколько вилок)
int sem_wait(sem_t *sem);
	- value-- (если value > 0)
int sem_post(sem_t *sem);
	- value++ (другой поток ждет пока value станет > 0)